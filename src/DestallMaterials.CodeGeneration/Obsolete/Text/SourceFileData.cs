using DestallMaterials.WheelProtection.Extensions.Strings;

namespace DestallMaterials.CodeGeneration.Text;

public class SourceFileData
{
    const string commentLine = "Autogenerated. Will be overwritten on build. Remove this comment to cancel overwriting.";
    private static Dictionary<string, string> Extension_LineCommentPattern;

    private string GetCommentString(string comment)
    {
        var res = string.Format(Extension_LineCommentPattern[FilePath.Extension], comment);
        return res;
    }

    internal static void LoadLineCommentPatterns(Dictionary<string, string> patterns)
    {
        Extension_LineCommentPattern = patterns.ToDictionary(p => p.Key, p => p.Value);
    }

    /// <summary>
    /// Absolute file path
    /// </summary>
    public FilePath? FilePath;
    
    /// <summary>
    /// Code contained in the file
    /// </summary>
    public string Content = "";

    /// <summary>
    /// Code is to be added to compliation, without creating real files.
    /// </summary>
    public bool PureVirtual;

    public bool Exists() => File.Exists(FilePath.ToString());

    public string Read()
    {
        if (!Exists()) { return null; }
        var res = File.ReadAllText(FilePath.ToString());
        return res;
    }

    public bool OverwriteProtected()
    {
        if (!Exists()) { return false; }
        if (!Extension_LineCommentPattern.ContainsKey(FilePath.Extension))
        {
            return false;
        }

        var commentedString = GetCommentString(commentLine);

        return !Read().Contains(commentedString);
    }

    public void AddAutogeneratedComment()
    {
        if (!Extension_LineCommentPattern.ContainsKey(FilePath.Extension)) { return; }
        var commentedString = GetCommentString(commentLine);
        Content = $"{commentedString}\n\n{Content}";
    }

    public override string ToString() => FilePath?.FileName + FilePath?.Extension.MustStartWith('.');
}
