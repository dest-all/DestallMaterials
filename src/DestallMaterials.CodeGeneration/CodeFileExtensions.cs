using DestallMaterials.WheelProtection.Extensions.Strings;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;
using System.Runtime;

namespace DestallMaterials.CodeGeneration;

public static class CodeFileExtensions
{
    public static bool IsCharpFile(this CodeFile codeFile)
        => codeFile.Path.FileName.ToLower().EndsWith(".cs", ".razor");

    /// <summary>
    /// Find document with the presented <see cref="relativePath" />
    /// </summary>
    /// <param name="documents">Sequence of documents to seek in.</param>
    /// <param name="relativePath">Path</param>
    /// <returns></returns>
    public static Document? Find(this IEnumerable<Document> documents, ProjectRelativeFilePath relativePath)
        => documents.FirstOrDefault(d => d.Project.Name == relativePath.ProjectName && d.Name == relativePath.FileName && GetFoldersHierarchy(d).SequenceEqual(relativePath.Folders));


    /// <summary>
    /// Makes sure that the resultant Project object has the file specified.
    /// </summary>
    /// <param name="project">Input project</param>
    /// <param name="sourceFile">File (document) data</param>
    /// <param name="cancellationToken">Token to cancel operation</param>
    /// <returns>The same project, if exact same file OR if non-autogenerated replacement file had already existed. Otherwise - new Project with existing file. 
    /// Hint: Compare input and output references to know whether document had existed or not.</returns>
    public static async ValueTask<Project> WithAsync(this Project project, CodeFile sourceFile, CancellationToken cancellationToken = default)
    {
        var (_, folders, fileName) = sourceFile.Path;
        folders = folders ?? [];

        sourceFile = sourceFile.FormatCsharpCode();

        var content = sourceFile.Content;
        var originaFilelName = sourceFile.Path.FileName;

        var finalFilePath = sourceFile.Path;

        var existingAutogeneratedFile = project.Documents.Find(finalFilePath);

        Project result;
        if (existingAutogeneratedFile is not null)
        {
            var existingText = await existingAutogeneratedFile.GetTextAsync(cancellationToken);
            var sourceContent = SourceText.From(content);

            if (existingText.ToString() == content)
            {
                return project;
            }
            result = existingAutogeneratedFile.WithText(sourceContent).Project;
            return result;
        }

        result = project.AddDocument(fileName, content, folders).Project;
        return result;
    }

    static IEnumerable<string> GetFoldersHierarchy(Document document)
    {
        if (document.FilePath is null)
        {
            return document.Folders;
        }

        var projectDirectoryLocation = Directory.GetParent(document.Project.FilePath).FullName;

        if (!document.FilePath.StartsWith(projectDirectoryLocation))
        {
            throw new SourceCodeGenerationException("Document is not located at project folder.");
        }

        var pastPath = document.FilePath[(projectDirectoryLocation.Length + 1)..];

        var result = pastPath.Split(Path.DirectorySeparatorChar)[..^1];

        return result;
    }
}