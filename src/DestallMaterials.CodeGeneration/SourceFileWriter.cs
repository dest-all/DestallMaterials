using DestallMaterials.WheelProtection.Extensions.Strings;
using DestallMaterials.WheelProtection.Linq;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.Text;
using System.Configuration;

namespace DestallMaterials.CodeGeneration;


/// <summary>
/// Settings for code generation workspace
/// </summary>
/// <param name="TransformFilePathBeforeWriting">How to change file path for writing</param>
public record struct SourceFilesWritingSettings(
    Func<ProjectRelativeFilePath, ProjectRelativeFilePath> TransformFilePathBeforeWriting)
{
    public static SourceFilesWritingSettings Standard
        => new(
                TransformFilePathBeforeWriting: path =>
                {
                    if (path.FileExtension != "razor")
                    {
                        path = path with { FileName = WithAutogeneratedAnnotation(path.FileName) };
                    }

                    if (path.Folders.FirstOrDefault() != "Autogenerated")
                    {
                        path = path with { Folders = path.Folders.Prepend("Autogenerated").ToArray() };
                    }

                    return path;
                }
            );

    public static SourceFilesWritingSettings FolderAdded
        => new(
                TransformFilePathBeforeWriting: path =>
                {
                    if (path.Folders.FirstOrDefault() != "Autogenerated")
                    {
                        path = path with { Folders = path.Folders.Prepend("Autogenerated").ToArray() };
                    }

                    return path;
                }
            );

    public static SourceFilesWritingSettings NameAnnotated
        => new(
                TransformFilePathBeforeWriting: path =>
                {
                    if (path.FileExtension != "razor")
                    {
                        path = path with { FileName = WithAutogeneratedAnnotation(path.FileName) };
                    } 
                    else if (path.Folders.FirstOrDefault() != "Autogenerated")
                    {
                        path = path with { Folders = path.Folders.Prepend("Autogenerated").ToArray() };
                    }

                    return path;
                }
            );

    /// <summary>
    /// Prepends "g." to file extension.
    /// </summary>
    /// <param name="fileName"></param>
    /// <returns></returns>
    public static string WithAutogeneratedAnnotation(string fileName)
    {
        var splitted = fileName.Split('.');

        if (splitted.Length > 2 && splitted[^2] == "g")
        {
            return fileName;
        }

        splitted[^1] = "g." + splitted[^1];

        fileName = splitted.Join(".");

        return fileName;
    }
}

public static class CodeFileWritingExtensions
{
    public const string AutogeneratedBeginning = "This file is autogenerated and its content will be overwritten. Remove this line to cancel overwriting.";

    static readonly Dictionary<string, string> _initialComments = (
            "razor", "@*{0}*@",
            "cs", "/*{0}*/",
            "bat", "rem {0}",
            "py", "# {0}",
            "c", "/*{0}*/",
            "cpp", "/*{0}*/",
            "json", "/*{0}*/"
        ).ToDictionary();

    /// <summary>
    /// Mark source file with .g annotation, which means the file has been autogenerated.
    /// Unless the file is a .razor file - this would butcher the component's name
    /// </summary>
    /// <param name="source"></param>
    /// <returns></returns>
    public static CodeFile WithAutogeneratedContentMark(this CodeFile source)
    {
        var result = (source with
        {
            Path = source.Path with
            {
                FileName = source.Path.FileName
            }
        }).WithAutogeneratedComment();

        return result;
    }


    

    internal static CodeFile FormatCsharpCode(this CodeFile codeFile) => codeFile.IsCharpFile() ? codeFile with
    {
        Content = CSharpSyntaxTree
            .ParseText(codeFile.Content)
            .GetRoot()
            .NormalizeWhitespace()
            .ToFullString()
    } : codeFile;

    public static CodeFile WithAutogeneratedComment(this CodeFile codeFile)
    {
        string newContent = $@"{GetComment(codeFile.Path.FileExtension, AutogeneratedBeginning)}
{GetComment(codeFile.Path.FileExtension, $"Generated at: {DateTimeOffset.UtcNow}")}
-----------------------------------------------------------------------------------------------


";
        return codeFile with { Content = newContent };
    }





    static string GetComment(string extension, string commentedContent)
    {
        string result;
        if (_initialComments.TryGetValue(extension, out var commentPattern))
        {
            result = string.Format(commentPattern, commentedContent);
        }
        else
        {
            result = $"/*{commentedContent}*/";
        }

        return result;
    }
}

public class SourceFileWriter
{
    readonly CodeGenerationWorkspace _codeGenerationWorkspace;
    readonly SourceFilesWritingSettings _settings;
    readonly SourceFileRenderer _sourceFileRenderer;

    public SourceFileWriter(
        CodeGenerationWorkspace codeGenerationWorkspace,
        SourceFileRenderer sourceFileRenderer,
        SourceFilesWritingSettings settings)
    {
        _codeGenerationWorkspace = codeGenerationWorkspace;
        _settings = settings;
        _sourceFileRenderer = sourceFileRenderer;
    }

    /// <summary>
    /// Write file physically to file system.
    /// </summary>
    /// <param name="workspace">Code generation workspace</param>
    /// <param name="sourceFile">File to write</param>
    /// <param name="cancellationToken">Cancellation</param>
    /// <returns>Absolute path to the written in file</returns>
    async Task<string> WriteAsync(CodeFile sourceFile, CancellationToken cancellationToken)
    {
        var workspace = _codeGenerationWorkspace;
        if (sourceFile.Virtual)
        {
            throw new InvalidOperationException($"File {sourceFile.Path} marked as virtual but an attempt to write it has been made.");
        }

        var absolutePath = workspace.ToAbsolutePath(sourceFile.Path);

        var directory = Path.GetDirectoryName(absolutePath)!;
        Directory.CreateDirectory(directory);

        await File.WriteAllTextAsync(absolutePath, sourceFile.Content, cancellationToken);

        return absolutePath;
    }

    /// <summary>
    /// Makes sure that the resultant Project object has the file specified.
    /// </summary>
    /// <param name="project">Input project</param>
    /// <param name="sourceFile">File (document) data</param>
    /// <param name="cancellationToken">Token to cancel operation</param>
    /// <returns>The same project, if exact same file OR if non-autogenerated replacement file had already existed. Otherwise - new Project with existing file. 
    /// Hint: Compare input and output references to know whether document had existed or not.</returns>
    public async ValueTask<Project> WithAsync(Project project, CodeFile sourceFile, CancellationToken cancellationToken = default)
    {
        var (_, folders, fileName) = sourceFile.Path;
        folders = folders ?? [];

        sourceFile = sourceFile.FormatCsharpCode();

        var content = sourceFile.Content;

        var originaFilelName = sourceFile.Path.FileName;

        var finalFilePath = _settings.TransformFilePathBeforeWriting(sourceFile.Path);

        var replacementFile = project.Documents.Find(finalFilePath with { FileName = originaFilelName });
        if (replacementFile is not null)
        {
            return project;
        }

        var existingAutogeneratedFile = project.Documents.Find(finalFilePath);

        Project result;
        if (existingAutogeneratedFile is not null)
        {
            var existingText = await existingAutogeneratedFile.GetTextAsync(cancellationToken);
            var sourceContent = SourceText.From(content);

            if (existingText.ToString() == content)
            {
                return project;
            }
            result = existingAutogeneratedFile.WithText(sourceContent).Project;
            return result;
        }

        result = project.AddDocument(fileName, content, folders).Project;
        return result;
    }

    /// <summary>
    /// Render templated code and include it into the workspace. Doesn't create physical files.
    /// </summary>
    /// <typeparam name="TComponent">Component to use as source code rendering template</typeparam>
    /// <param name="sourceFileRenderer">Preconfigured source code templates renderer</param>
    /// <param name="codeGenerationWorkspace">Workspace to put rendered code to</param>
    /// <param name="parameters">Parameters to pass to the rendered template</param>
    /// <param name="cancellationToken">Cancellation</param>
    /// <returns>Files added to the workspace, that were not present before</returns>
    public async Task<IReadOnlyList<CodeFile>> AddFilesToWorkspaceAsync<TComponent>(
        IEnumerable<KeyValuePair<string, object>> parameters,
        CancellationToken cancellationToken)
        where TComponent : SourceGenerationTemplate
    {
        var sourceFiles = _sourceFileRenderer.RenderSourceCode<TComponent>(parameters);
        var addedSourceFiles = await _codeGenerationWorkspace.AddSourceFilesAsync(sourceFiles, cancellationToken);

        return addedSourceFiles;
    }

    /// <summary>
    /// Write physical files to the solution behind the workspace.
    /// </summary>
    /// <param name="sourceFilesWriter">Workspace to accept files</param>
    /// <param name="sourceFiles">Files to write</param>
    /// <param name="cancellationToken">Cancellation</param>
    /// <returns>Written file paths</returns>
    public async Task<IReadOnlyList<string>> WriteFilesAsync(
        IEnumerable<CodeFile> sourceFiles,
        CancellationToken cancellationToken)
    {
        List<string> results = new();
        foreach (var sourceFile in sourceFiles)
        {
            if (sourceFile.Virtual)
            {
                continue;
            }

            var file = await WriteAsync(sourceFile, cancellationToken);
            results.Add(file);
        }
        return results;
    }

    /// <summary>
    /// Render templated code and include it into the workspace. Creates physical source files, according to the template.
    /// </summary>
    /// <typeparam name="TComponent">Component to use as source code rendering template</typeparam>
    /// <param name="parameters">Parameters to pass to the rendered template</param>
    /// <param name="cancellationToken">Cancellation</param>
    /// <returns>Files added to the workspace, that haven't been present before</returns>
    public async Task<IReadOnlyList<string>> WriteToWorkspaceAsync<TComponent>(
        IEnumerable<KeyValuePair<string, object>> parameters,
        CancellationToken cancellationToken)
        where TComponent : SourceGenerationTemplate
    {
        var addedFiles = await AddFilesToWorkspaceAsync<TComponent>(parameters, cancellationToken);
        var result = await WriteFilesAsync(addedFiles, cancellationToken);
        return result;
    }
}
