using DestallMaterials.WheelProtection.Extensions.Enumerables;
using DestallMaterials.WheelProtection.Extensions.Strings;
using DestallMaterials.WheelProtection.Linq;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;

namespace DestallMaterials.CodeGeneration;

public static class SourceFileWriter
{
    /// <summary>
    /// Compose file system path for project-based path.
    /// </summary>
    /// <param name="sourceFilePath"></param>
    /// <returns></returns>
    public static string ToAbsolutePath(this CodeGenerationWorkspace pathFinder, ProjectRelativeFilePath sourceFilePath)
    {
        var projectName = sourceFilePath.ProjectName;

        var projectDirectory = Directory.GetParent(pathFinder.ProjectLocations[projectName])?.FullName
            ?? throw new DirectoryNotFoundException();

        sourceFilePath = sourceFilePath with { ProjectName = projectDirectory };

        var result = sourceFilePath.ToString();

        return result;
    }

    public static async Task WriteAsync(this CodeGenerationWorkspace pathFinder, CodeFile sourceFile, CancellationToken cancellationToken)
    {
        var absolutePath = pathFinder.ToAbsolutePath(sourceFile.Path);
        await File.WriteAllTextAsync(absolutePath, sourceFile.Content, cancellationToken);
    }

    /// <summary>
    /// Makes sure that the resultant Project object has the file specified.
    /// </summary>
    /// <param name="project">Input project</param>
    /// <param name="sourceFile">File (document) data</param>
    /// <param name="cancellationToken">Token to cancel operation</param>
    /// <returns>The same project, if exact same file had already existed. Otherwise - new Project with existing file. 
    /// Hint: Compare input and output references to know whether document had existed or not.</returns>
    public static async ValueTask<Project> WithAsync(this Project project, CodeFile sourceFile, CancellationToken cancellationToken = default)
    {
        var (_, folders, fileName) = sourceFile.Path;
        var content = sourceFile.Content;

        var autogenFileName = WithAutogeneratedAnnotation(fileName);

        var existingFile = project.Documents.FirstOrDefault(d => (autogenFileName, fileName).Contains(d.Name) && folders.IsIdentical(d.Folders));

        Project result;
        if (existingFile is not null)
        {
            var existingText = await existingFile.GetTextAsync(cancellationToken);
            var sourceContent = SourceText.From(content);

            if (existingText == sourceContent)
            {
                return project;
            }
            result = existingFile.WithText(sourceContent).Project;
            return result;
        }

        result = project.AddDocument(fileName, content, folders).Project;
        return result;
    }

    /// <summary>
    /// Mark source file with .g annotation, which means the file has been autogenerated.
    /// </summary>
    /// <param name="source"></param>
    /// <returns></returns>
    public static CodeFile WithAutogeneratedAnnotation(this CodeFile source)
    {
        var fileName = WithAutogeneratedAnnotation(source.Path.FileName);

        var result = source with
        {
            Path = source.Path with
            {
                FileName = fileName
            }
        };

        return result;
    }

    /// <summary>
    /// Prepends "g." to file extension.
    /// </summary>
    /// <param name="fileName"></param>
    /// <returns></returns>
    public static string WithAutogeneratedAnnotation(string fileName)
    {
        var splitted = fileName.Split('.');

        if (splitted.Length > 2 && splitted[^2] == "g")
        {
            return fileName;
        }

        splitted[^1] = "g." + splitted[^1];

        fileName = splitted.Join(".");

        return fileName;
    }
}
