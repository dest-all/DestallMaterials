using DestallMaterials.WheelProtection.Extensions.Strings;
using DestallMaterials.WheelProtection.Linq;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.Text;
using System.Configuration;

namespace DestallMaterials.CodeGeneration;

public static class SourceFileWriter
{
    public const string AutogeneratedBeginning = "This file is autogenerated and its content will be overwritten. Remove this line to cancel overwriting.";

    static readonly Dictionary<string, string> _initialComments = (
            "razor", "@*{0}*@",
            "cs", "/*{0}*/",
            "bat", "rem {0}",
            "py", "# {0}",
            "c", "/*{0}*/",
            "cpp", "/*{0}*/",
            "json", "/*{0}*/"
        ).ToDictionary();

    /// <summary>
    /// Compose file system path for project-based path.
    /// </summary>
    /// <param name="sourceFilePath"></param>
    /// <returns></returns>
    public static string ToAbsolutePath(this CodeGenerationWorkspace workspace, ProjectRelativeFilePath sourceFilePath)
    {
        var projectName = sourceFilePath.ProjectName;

        var projectDirectory = Directory.GetParent(workspace.ProjectLocations[projectName])?.FullName
            ?? throw new DirectoryNotFoundException();

        sourceFilePath = sourceFilePath with { ProjectName = projectDirectory };

        var result = sourceFilePath.ToString();

        if (Path.DirectorySeparatorChar != '/')
        {
            result = result.Replace('/', Path.DirectorySeparatorChar);
        }

        return result;
    }

    /// <summary>
    /// Write file physically to file system.
    /// </summary>
    /// <param name="workspace">Code generation workspace</param>
    /// <param name="sourceFile">File to write</param>
    /// <param name="cancellationToken">Cancellation</param>
    /// <returns>Absolute path to the written in file</returns>
    public static async Task<string> WriteAsync(this CodeGenerationWorkspace workspace, CodeFile sourceFile, CancellationToken cancellationToken)
    {
        if (sourceFile.Virtual)
        {
            throw new InvalidOperationException($"File {sourceFile.Path} marked as virtual but an attempt to write it has been made.");
        }

        var absolutePath = workspace.ToAbsolutePath(sourceFile.Path);

        var directory = Path.GetDirectoryName(absolutePath)!;
        Directory.CreateDirectory(directory);

        await File.WriteAllTextAsync(absolutePath, sourceFile.Content, cancellationToken);

        return absolutePath;
    }

    /// <summary>
    /// Makes sure that the resultant Project object has the file specified.
    /// </summary>
    /// <param name="project">Input project</param>
    /// <param name="sourceFile">File (document) data</param>
    /// <param name="cancellationToken">Token to cancel operation</param>
    /// <returns>The same project, if exact same file OR if non-autogenerated replacement file had already existed. Otherwise - new Project with existing file. 
    /// Hint: Compare input and output references to know whether document had existed or not.</returns>
    public static async ValueTask<Project> WithAsync(this Project project, CodeFile sourceFile, CancellationToken cancellationToken = default)
    {
        var (_, folders, fileName) = sourceFile.Path;
        folders = folders ?? Array.Empty<string>();

        sourceFile = sourceFile.FormatCsharpCode();

        var content = sourceFile.Content;

        var replacementFile = project.Documents.Find(sourceFile.Path);
        if (replacementFile is not null)
        {
            return project;
        }

        var autogenFileName = WithAutogeneratedAnnotation(fileName);
        var existingAutogeneratedFile = project.Documents.Find(sourceFile.Path with { FileName = autogenFileName });

        Project result;
        if (existingAutogeneratedFile is not null)
        {
            var existingText = await existingAutogeneratedFile.GetTextAsync(cancellationToken);
            var sourceContent = SourceText.From(content);

            if (existingText.ToString() == content)
            {
                return project;
            }
            result = existingAutogeneratedFile.WithText(sourceContent).Project;
            return result;
        }

        result = project.AddDocument(fileName, content, folders).Project;
        return result;
    }

    /// <summary>
    /// Mark source file with .g annotation, which means the file has been autogenerated.
    /// Unless the file is a .razor file - this would butcher the component's name
    /// </summary>
    /// <param name="source"></param>
    /// <returns></returns>
    public static CodeFile WithAutogeneratedMark(this CodeFile source)
    {
        if (source.Path.FileExtension == "razor")
        {
            return source;
        }

        var fileName = WithAutogeneratedAnnotation(source.Path.FileName);

        var result = (source with
        {
            Path = source.Path with
            {
                FileName = fileName
            }
        }).WithAutogeneratedComment();

        return result;
    }

    /// <summary>
    /// Prepends "g." to file extension.
    /// </summary>
    /// <param name="fileName"></param>
    /// <returns></returns>
    public static string WithAutogeneratedAnnotation(string fileName)
    {
        var splitted = fileName.Split('.');

        if (splitted.Length > 2 && splitted[^2] == "g")
        {
            return fileName;
        }

        splitted[^1] = "g." + splitted[^1];

        fileName = splitted.Join(".");

        return fileName;
    }

    static CodeFile FormatCsharpCode(this CodeFile codeFile) => codeFile.IsCharpFile() ? codeFile with
    {
        Content = CSharpSyntaxTree
            .ParseText(codeFile.Content)
            .GetRoot()
            .NormalizeWhitespace()
            .ToFullString() 
    } : codeFile;

    public static CodeFile WithAutogeneratedComment(this CodeFile codeFile)
    {
        string newContent = $@"{GetComment(codeFile.Path.FileExtension, AutogeneratedBeginning)}
{GetComment(codeFile.Path.FileExtension, $"Generated at: {DateTimeOffset.UtcNow}")}
-----------------------------------------------------------------------------------------------


";
        return codeFile with { Content = newContent };
    }

    static string GetComment(string extension, string commentedContent)
    {
        string result;
        if (_initialComments.TryGetValue(extension, out var commentPattern))
        {
            result = string.Format(commentPattern, commentedContent);
        }
        else
        {
            result = $"/*{commentedContent}*/";
        }

        return result;
    }
}
