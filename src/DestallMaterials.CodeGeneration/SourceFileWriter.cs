using BlazorTemplater;
using DestallMaterials.WheelProtection.Extensions.Enumerables;
using DestallMaterials.WheelProtection.Extensions.Strings;
using DestallMaterials.WheelProtection.Extensions.Tuples;
using Microsoft.AspNetCore.Components;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;

namespace DestallMaterials.CodeGeneration;

public static class SourceFileWriter
{
    /// <summary>
    /// Compose file system path for project-based path.
    /// </summary>
    /// <param name="sourceFilePath"></param>
    /// <returns></returns>
    public static string ToAbsolutePath(this CodeGenerationWorkspace pathFinder, ProjectRelativeFilePath sourceFilePath)
    {
        var projectName = sourceFilePath.ProjectName;

        var projectDirectory = Directory.GetParent(pathFinder.ProjectLocations[projectName])?.FullName
            ?? throw new DirectoryNotFoundException();

        sourceFilePath = sourceFilePath with { ProjectName = projectDirectory };

        var result = sourceFilePath.ToString();

        return result;
    }

    public static async Task WriteAsync(this CodeGenerationWorkspace pathFinder, CodeFile sourceFile, CancellationToken cancellationToken)
    {
        var absolutePath = pathFinder.ToAbsolutePath(sourceFile.Path);
        await File.WriteAllTextAsync(absolutePath, sourceFile.Content, cancellationToken);
    }

    /// <summary>
    /// Makes sure that the resultant Project object has the file specified.
    /// </summary>
    /// <param name="project">Input project</param>
    /// <param name="sourceFile">File (document) data</param>
    /// <param name="cancellationToken">Token to cancel operation</param>
    /// <returns>The same project, if exact same file had already existed. Otherwise - new Project with existing file. 
    /// Compare input and output references to know if document had existed or not.</returns>
    public static async ValueTask<Project> WithAsync(this Project project, CodeFile sourceFile, CancellationToken cancellationToken = default)
    {
        var (_, folders, fileName) = sourceFile.Path;
        var content = sourceFile.Content;

        var autogenFileName = WithAutogeneratedAnnotation(fileName);

        var existingFile = project.Documents.FirstOrDefault(d => (autogenFileName, fileName).Contains(d.Name) && folders.IsIdentical(d.Folders));

        Project result;
        if (existingFile is not null)
        {
            var existingText = await existingFile.GetTextAsync(cancellationToken);
            var sourceContent = SourceText.From(content);

            if (existingText == sourceContent)
            {
                return project;
            }
            result = existingFile.WithText(sourceContent).Project;
            return result;
        }

        result = project.AddDocument(fileName, content, folders).Project;
        return result;
    }

    /// <summary>
    /// Mark source file with .g annotation, which means the file has been autogenerated.
    /// </summary>
    /// <param name="source"></param>
    /// <returns></returns>
    public static CodeFile WithAutogeneratedAnnotation(this CodeFile source)
    {
        var fileName = WithAutogeneratedAnnotation(source.Path.FileName);

        var result = source with
        {
            Path = source.Path with
            {
                FileName = fileName
            }
        };

        return result;
    }

    /// <summary>
    /// Prepends "g." to file extension.
    /// </summary>
    /// <param name="fileName"></param>
    /// <returns></returns>
    public static string WithAutogeneratedAnnotation(string fileName)
    {
        var splitted = fileName.Split('.');

        if (splitted.Length > 2 && splitted[^2] == "g")
        {
            return fileName;
        }

        splitted[^1] = "g." + splitted[^1];

        fileName = splitted.Join(".");

        return fileName;
    }
}


/// <summary>
/// Serves to render source code components with Compilation.
/// </summary>
public sealed class SourceFileRenderer
{
    readonly Action<ComponentRenderer<DynamicComponent>> _configureComponentRenderer;

    /// <summary>
    /// Initialize
    /// </summary>
    /// <param name="configureRenderer">Configure service contracts that will be applied to every component renderer, created every time <see cref="RenderSourceCode<TComponent>" is called.></param>
    public SourceFileRenderer(Action<ComponentRenderer<DynamicComponent>> configureRenderer)
    {
        _configureComponentRenderer = configureRenderer;
    }

    /// <summary>
    /// Render source code template to Source code files.
    /// </summary>
    /// <typeparam name="TComponent"></typeparam>
    /// <param name="compilation"></param>
    /// <returns></returns>
    public IEnumerable<CodeFile> RenderSourceCode<TComponent>(Compilation compilation)
        where TComponent : CodeGenerationEntryPoint
    {
        var renderer = new ComponentRenderer<DynamicComponent>();

        _configureComponentRenderer(renderer);

        renderer.Set(c => c.Type, typeof(TComponent));
        renderer.Set(c => c.Parameters, new Dictionary<string, object>
        {
            { "Compilation", compilation }
        });

        var stringResult = renderer.Render();

        var result = CodeFile.ParseMany(stringResult);

        return result;
    }
}

public static class CodeFilesAddingExtensions
{
    public static async Task<IReadOnlyList<CodeFile>> RenderToSystemAsync<TComponent>(this SourceFileRenderer sourceFileRenderer, string projectName, CodeGenerationWorkspace codeGenerationSystem, CancellationToken cancellationToken)
        where TComponent : CodeGenerationEntryPoint
    {
        var compilation = await codeGenerationSystem.GetProjectCompilationAsync(projectName);

        var sourceFiles = sourceFileRenderer.RenderSourceCode<TComponent>(compilation!);

        var addedSourceFiles = await codeGenerationSystem.AddSourceFilesAsync(sourceFiles, cancellationToken);

        return addedSourceFiles;
    }
}