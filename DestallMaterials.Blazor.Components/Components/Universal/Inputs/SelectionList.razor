@using DestallMaterials.Blazor.Functions
@using DestallMaterials.Blazor.Services.Extensions
@using MudBlazor

@inherits ClickableComponent

@inject IJSRuntime js;

@typeparam TItem

<ul class="selection-list"
    @ref=_listElement
    @onmouseover="() => OnMouseIn()"
    @onmouseout="() => OnMouserOut()">

    @{
        int i = 0;
    }
    <Virtualize ItemsProvider="async r => await ProvideItems(r)" TItem="TItem" Context="item">
        @{
            bool selected = _selectedItemIndex == i++;
            string representation = GetItemRepresentation(item);
            string cssClass = selected ? "selected" : "";
        }
        <li class="@cssClass" @onclick="() => ClickItem(item)">
            @representation
        </li>
    </Virtualize>

</ul>


@code {
    [Parameter]
    public uint MaxItemsShown { get; set; } = 10;

    [Parameter]
    public Action<TItem> OnItemClicked { get; set; } = i => { };

    [Parameter]
    public Action<TItem> OnItemExcluded { get; set; } = i => { };

    [Parameter]
    [EditorRequired]
    public int ItemsCountTotal { get; set; }

    [Parameter]
    [EditorRequired]
    public Func<uint, Task<IList<TItem>>> GetBatch { get; set; }

    [Parameter]
    public uint BatchSize { get; set; } = 10;

    [Parameter]
    public Func<TItem, string> GetItemRepresentation { get; set; } = i => i.ToString();

    [Parameter]
    public Func<TItem, TItem, bool> ItemsComparison { get; set; } = (i1, i2) => i1.Equals(i2);

    [Parameter]
    public string InputLabel { get; set; }

    [Parameter]
    public Func<TItem, bool> ItemIsEmpty { get; set; } = i => i == null;

    [Parameter]
    public Action OnListClick { get; set; } = null;

    public TItem SelectedItem
    {
        get
        {
            {
                if (_currentBatch == null)
                {
                    return default;
                }
                if (_currentBatch.Count <= _selectedItemIndex)
                {
                    _selectedItemIndex = -1;
                    return default;
                }
                var result = _currentBatch[_selectedItemIndex];
                return result;
            }
        }
    }

    async Task<IEnumerable<TItem>> DownloadItemsOnDemandAsync(uint startIndex, uint count, uint pageSize)
    {
        return await DynamicLoading.LoadForVirtualizationInPagesAsync(
            (int)startIndex,
            (int)count,
            pageSize,
            async p => await GetBatch(p)
        );
    }

    async Task<ItemsProviderResult<TItem>> ProvideItems(ItemsProviderRequest request)
    {
        var items = await DownloadItemsOnDemandAsync((uint)request.StartIndex, (uint)request.Count, BatchSize);
        if (!items.Any())
        {
            _selectedItemIndex = -1;
        }
        return new(items, ItemsCountTotal);
    }

    int _currentPage;

    private IList<TItem> _currentBatch;

    int _selectedItemIndex = -1;

    void ClickItem(TItem item)
    {
        OnItemClicked(item);
        Console.WriteLine($"Item {GetItemRepresentation(item)} clicked.");
        StateHasChanged();
    }

    void SpacePressed()
    {
        if (_selectedItemIndex != -1)
        {
            var selectedItem = SelectedItem;
            if (!ItemIsEmpty(selectedItem))
            {
                OnItemClicked(SelectedItem);
            }
        }
    }

    void OnMouseIn()
    {
        _mouseIn = true;
    }
    void OnMouserOut()
    {
        _mouseIn = false;
    }

    void ArrowUp()
    {
        if (_selectedItemIndex > _topIndex)
        {
            _selectedItemIndex--;
            StateHasChanged();
        }
        else if (_topIndex > 0)
        {
            _topIndex--;
            _selectedItemIndex--;
            StateHasChanged();
        }
        else if (ItemsCountTotal <= BatchSize)
        {
            _selectedItemIndex = (int)_bottomIndex;
            StateHasChanged();
        }
        Console.WriteLine("Arrow up.");

    }

    void ArrowDown()
    {

        if (_selectedItemIndex < _bottomIndex)
        {
            _selectedItemIndex++;
            StateHasChanged();
        }
        else if (_bottomIndex < ItemsCountTotal - 1)
        {
            _bottomIndex++;
            _selectedItemIndex++;
            StateHasChanged();
        }
        else if (ItemsCountTotal <= BatchSize)
        {
            _selectedItemIndex = (int)_topIndex;
            StateHasChanged();
        }
        Console.WriteLine("Arrow down.");

    }

    protected override void OnAfterRender(bool firstRender)
    {
        if (firstRender)
        {
            Subscribe(globalClickCatcher.OnKeyPressed(Key.ArrowUp, e => ArrowUp()));
            Subscribe(globalClickCatcher.OnKeyPressed(Key.ArrowDown, e => ArrowDown()));
            Subscribe(globalClickCatcher.OnKeyPressed(Key.Space, e => SpacePressed()));
            Subscribe(globalClickCatcher.OnKeyPressed(Key.Enter, e => SpacePressed()));
        }
    }

    protected override void OnParametersSet()
    {
        OnListClick = OnListClick ?? (() => _listElement.FocusAsync());
    }

    protected override async Task OnParametersSetAsync()
    {
        _topIndex = 0;
        _bottomIndex = _topIndex + MaxItemsShown;
        Items = await CalculateItemsListAsync();

        await uiManipulator.SayHi("Igor");
    }

    ElementReference _listElement;

    uint _topIndex;
    uint _bottomIndex;

    IList<TItem> Items = new List<TItem>();

    async Task<IList<TItem>> CalculateItemsListAsync()
    {
        var itemsToLoad = _bottomIndex - _topIndex + 1;
        var items = await DynamicLoading.LoadForVirtualizationInPagesAsync(
            (int)_topIndex,
            (int)itemsToLoad,
            BatchSize,
            page => GetBatch(page)
        );

        return items;
    }
}
