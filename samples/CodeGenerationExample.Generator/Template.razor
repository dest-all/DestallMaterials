@using CodeGenerationExample.ClientDependency;
@using DestallMaterials.CodeGeneration;
@using Microsoft.CodeAnalysis;


@inherits CodegenComponent

@inject Logger logger; 
@*Dependency injection is supported*@


@{
    var info = CollectInfo();

    logger.Log($"Attribute {typeof(TargetClassAttribute).FullName} is carried by {info.Length} classes.");
}

@foreach (var _ in Enumerable.Range(0,1)) // multiple files creation is possible
{
    <File Path="@_filePath"> @*The 'Path' attribute should be written exactly like this.*@

        @*Here resides the full content of autogenerated file*@


        namespace CodeGenerationExample.Target;

        public static partial class InfoProvider
        {
            public static void PrintInfo()
            {
                @foreach (var infoItem in info)
                {
                    <text> @*To type in text use this tag. Its content will be written. The tag boundaries itself won't be included.*@
                        Console.WriteLine("@(infoItem)");
                    </text>     
                }
            }
        }


    </File>

}

@code {
    const string _targetProjectName = "CodeGenerationExample.Target"; // must be equal to project name without .csproj part


    // Must be a relative path. Must start with the project, that you want to write files to.
    // Not necessarily a constant. Slashes are straight.
    // Intermediary Autogenerated folder is optional, but could be handy, when you want to delete all autogenerated files at once.
    // All the folders specified will be created at need.
    const string _filePath = $"{_targetProjectName}/Autogenerated/PropsIterator.cs";

    string[] CollectInfo()
    {
        var attributeCarriers = GetAttributeCarriers();

        var result = attributeCarriers.Select(carrierClass => new
        {
            TypeFullName = carrierClass.ToDisplayString(),
            Members = carrierClass.GetMembers().Select(m => m.Name)
        })
        .Select(info => $"{info.TypeFullName} has the following members: {string.Join(", ", info.Members)}.")
        .ToArray();

        return result;
    }

    SyntaxReceiver VisitAllNodes() // Special class is needed to collect information from Compilation object
    {
        var compilation = Compilation; // that's the whole information about syntax and semantics we need about the analyzed project.
        var syntaxReceiver = new SyntaxReceiver();
        foreach (var tree in compilation.SyntaxTrees)
        {
            syntaxReceiver.Visit(tree.GetRoot());
        }
        return syntaxReceiver;
    }

    IEnumerable<INamedTypeSymbol> GetAttributeCarriers() // Collecting class symbols will probably be enough for most of the cases.
    {
        var syntaxReceiver = VisitAllNodes();

        foreach (var classDeclarationSyntax in syntaxReceiver.AttributeBearingClasses)
        {
            var semanticModel = Compilation.GetSemanticModel(classDeclarationSyntax.SyntaxTree);

            var classSymbol = semanticModel.GetDeclaredSymbol(classDeclarationSyntax);

            if (classSymbol is INamedTypeSymbol nts)
            {
                bool hasSeekedAttribute = nts
                    .GetAttributes()
                    .Any(attr => attr.AttributeClass.ToDisplayString() == typeof(TargetClassAttribute).FullName); // this is why Generator must have 
                    // a reference to Client Dependency lib.

                if (hasSeekedAttribute)
                {
                    yield return nts;
                }
            }
        }
    }
}