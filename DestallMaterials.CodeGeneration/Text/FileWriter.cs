using DestallMaterials.CodeGeneration.Environment;
using Microsoft.Extensions.Logging;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;

namespace DestallMaterials.CodeGeneration.Text
{
    class FileWriter
    {
        private static readonly Regex _directoryPath = new Regex(@"(.*)\\(^\\)*", RegexOptions.IgnoreCase | RegexOptions.Compiled);
        private readonly SolutionPathFinder _pathFinder;
        private readonly ILogger _logger;
        private static readonly Regex _outpuFilesParser = new Regex(@"<(\s)*File(\s)*Path(\s)*=(\s)*""(?<Path>.*)"".*>(?<Content>(.|\s)*?)<(\s)*/(\s)*File(\s)*>", RegexOptions.Compiled);

        private static readonly string[] ExceptionsForUnicode = { "proto" };

        readonly ProjectCodeGenerationSettings _settings;

        public FileWriter(SolutionPathFinder pathFinder, ILogger logger)
        {
            _pathFinder = pathFinder;
            _logger = logger;
        }

        public static async Task WriteCreatingDirectoryAsync(FilePath filePath, string fileContent)
        {
            Directory.CreateDirectory(filePath.Directory);

            if (!ExceptionsForUnicode.Contains(filePath.Extension))
            {
                await File.WriteAllTextAsync(filePath.ToString(), fileContent, encoding: Encoding.Unicode);
            }
            else
            {
                await File.WriteAllTextAsync(filePath.ToString(), fileContent, Encoding.ASCII);
            }
        }

        public static async Task<bool> WriteIfDifferentAsync(FilePath filePath, string fileContent)
        {
            if (!File.Exists(filePath.ToString()))
            {
                await WriteCreatingDirectoryAsync(filePath, fileContent);
                return true;
            }

            var contentHash = fileContent.GetHashCode();
            var existingFileHash = (await File.ReadAllTextAsync(filePath.ToString())).GetHashCode();

            if (contentHash != existingFileHash)
            {
                await WriteCreatingDirectoryAsync(filePath, fileContent);
                return true;
            }

            return false;
        }



        internal IReadOnlyList<SourceFileData> SplitIntoFiles(string content, string source = null)
        {
            var matches = _outpuFilesParser.Matches(content);

            var exceptions = new List<Exception>();
            var result = new List<SourceFileData>();

            foreach (var fileParsed in matches.ToList())
            {
                string path = fileParsed.Groups["Path"].Value;
                string code = fileParsed.Groups["Content"].Value;
                try
                {
                    path = _pathFinder.RelativeToAbsolutePath(path) ?? throw new Exception($"Invalid path provided: {path}");
                }
                catch (Exception ex)
                {
                    exceptions.Add(ex);
                    continue;
                }

                result.Add(new SourceFileData
                {
                    Content = code,
                    FilePath = FilePath.Parse(path) ?? throw new InvalidOperationException($"Unable to parse {path} as file path."),
                    Source = source
                });
            }

            if (exceptions.Any())
            {
                throw new AggregateException(exceptions);
            }
            return result;
        }

        public async Task<int> WriteSourceFilesAsync(IEnumerable<SourceFileData> splittedSourceFiles)
        {
            var writingException = new List<Exception>();
            int i = 0;

            foreach (var codeFile in splittedSourceFiles)
            {
                try
                {
                    codeFile.Normalize();
                    if (!codeFile.OverwriteProtected())
                    {
                        codeFile.FilePath.FileName += _settings.GeneratedFileSuffix;
                        codeFile.AddAutogeneratedComment();
                        await WriteIfDifferentAsync(codeFile.FilePath, codeFile.Content);
                        i++;
                    }
                    if (!File.Exists(codeFile.FilePath.ToString()))
                    {
                        throw new Exception($"Could not create file on path {codeFile.FilePath}");
                    }
                }
                catch (Exception ex)
                {
                    writingException.Add(new Exception($"File {codeFile.FilePath} - " + ex.Message));
                }
            }
            if (writingException.Any())
            {
                var agex = new AggregateException("Error(s) writing files", writingException);
                _logger.LogError("", agex);
            }
            return i;
        }
    }
}
